<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"suwangsuwang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="深入剖析 iOS 编译 Clang &#x2F; LLVM前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析 iOS编译">
<meta property="og:url" content="https://suwangsuwang.github.io/2018/03/04/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang-LLVM/index.html">
<meta property="og:site_name" content="suwang Tech Blog">
<meta property="og:description" content="深入剖析 iOS 编译 Clang &#x2F; LLVM前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-03-04T05:24:15.000Z">
<meta property="article:modified_time" content="2023-06-07T15:20:23.000Z">
<meta property="article:author" content="suwang">
<meta property="article:tag" content="iOS, Swift, Objective-C, 技术博客, 编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://suwangsuwang.github.io/2018/03/04/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang-LLVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>剖析 iOS编译 | suwang Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">suwang Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Tech Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suwangsuwang.github.io/2018/03/04/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang-LLVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="suwang">
      <meta itemprop="description" content="Tech Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="suwang Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剖析 iOS编译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-04 13:24:15" itemprop="dateCreated datePublished" datetime="2018-03-04T13:24:15+08:00">2018-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 23:20:23" itemprop="dateModified" datetime="2023-06-07T23:20:23+08:00">2023-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="深入剖析-iOS-编译-Clang-LLVM"><a href="#深入剖析-iOS-编译-Clang-LLVM" class="headerlink" title="深入剖析 iOS 编译 Clang &#x2F; LLVM"></a>深入剖析 iOS 编译 Clang &#x2F; LLVM</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a target="_blank" rel="noopener" href="https://twitter.com/clattner_llvm">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP&#x2F;IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang &#x2F; LLVM 来编译的。</p>
<p>swift 是 Swift &#x2F; LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang &#x2F; LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<span id="more"></span>

<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a target="_blank" rel="noopener" href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/1436811/">《linkers and loaders》</a> 这本书就知道了。</p>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEEight 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> eight = DEFINEEight;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> six = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span>* site = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">&quot;starming&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rank = eight + six;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ rank %d&quot;</span>, site, rank);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在命令行输入</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -ccc-print-phases main.m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到编译源文件需要的几个不同的阶段</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>: input, <span class="string">&quot;main.m&quot;</span>, objective-c</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: preprocessor, &#123;<span class="number">0</span>&#125;, objective-c-cpp-output</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: compiler, &#123;<span class="number">1</span>&#125;, ir</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>: backend, &#123;<span class="number">2</span>&#125;, assembler</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>: assembler, &#123;<span class="number">3</span>&#125;, object</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>: linker, &#123;<span class="number">4</span>&#125;, image</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>: bind-arch, <span class="string">&quot;x86_64&quot;</span>, &#123;<span class="number">5</span>&#125;, image</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -rewrite-objc <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看操作内部命令，可以使用 -### 命令</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">clang -### main.m -o main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>想看清clang的全部过程，可以先通过-E查看clang在预处理处理这步做了什么。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -E <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行完后可以看到文件</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 1 <span class="string">&quot;/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot;</span> 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 185 <span class="string">&quot;/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot;</span> 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 2 <span class="string">&quot;main.m&quot;</span> 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> eight = <span class="number">8</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> six = <span class="number">6</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        NSString* site = [[NSString alloc] initWithUTF8String:<span class="string">&quot;starming&quot;</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rank = eight + six<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        NSLog(@<span class="string">&quot;%@ rank %d&quot;</span>, site, rank)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个过程的处理包括宏的替换，头文件的导入，以及类似#if的处理。预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -S -fobjc-arc -emit-llvm <span class="selector-tag">main</span><span class="selector-class">.m</span> -o <span class="selector-tag">main</span><span class="selector-class">.ll</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a target="_blank" rel="noopener" href="http://llvm.org/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 5 documentation</a> 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -O3 -S -fobjc-arc -emit-llvm <span class="selector-tag">main</span><span class="selector-class">.m</span> -o <span class="selector-tag">main</span><span class="selector-class">.ll</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c <span class="selector-tag">main</span><span class="selector-class">.m</span> -o <span class="selector-tag">main</span><span class="selector-class">.bc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成汇编</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -S -fobjc-arc <span class="selector-tag">main</span><span class="selector-class">.m</span> -o <span class="selector-tag">main</span><span class="selector-class">.s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成目标文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -fmodules -c <span class="selector-tag">main</span><span class="selector-class">.m</span> -o <span class="selector-tag">main</span><span class="selector-class">.o</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成可执行文件，这样就能够执行看到输出结果</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang <span class="selector-tag">main</span><span class="selector-class">.o</span> -o <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line"></span><br><span class="line">./<span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">starming rank <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h2 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h2><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CompileC DerivedData path/AFSecurityPolicy.<span class="keyword">o</span> AFNetworking/AFNetworking/AFSecurityPolicy.<span class="keyword">m</span> <span class="keyword">normal</span> x86_64 objective-<span class="keyword">c</span> <span class="keyword">com</span>.apple.compilers.llvm.clang.<span class="number">1</span>_0.<span class="keyword">compiler</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来对会更新工作路径，同时设置 PATH</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> <span class="attribute">LANG</span>=en_US.US-ASCII</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来就是实际的编译命令</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang <span class="operator">-</span>x objective<span class="operator">-</span><span class="built_in">c</span> <span class="operator">-</span>arch x86_64 <span class="operator">-</span>fmessage<span class="operator">-</span><span class="built_in">length</span><span class="operator">=</span><span class="number">0</span> <span class="operator">-</span>fobjc<span class="operator">-</span>arc... <span class="operator">-</span>Wno<span class="operator">-</span><span class="built_in">missing</span><span class="operator">-</span>field<span class="operator">-</span>initializers ... <span class="operator">-</span>DDEBUG<span class="operator">=</span><span class="number">1</span> ... <span class="operator">-</span>isysroot iPhoneSimulator10.1.sdk <span class="operator">-</span>fasm<span class="operator">-</span>blocks ... <span class="operator">-</span>I <span class="operator">-</span><span class="built_in">F</span> <span class="operator">-</span><span class="built_in">c</span> AFSecurityPolicy.m <span class="operator">-</span>o AFSecurityPolicy.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clang 命令参数</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-x 编译语言比如objective-c</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-arch 编译的架构，比如arm7</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-f 以-f开头的。</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-W 以-W开头的，可以通过这些定制编译警告</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-I 把编译信息写入指定的辅助文件</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-F 需要的Framework</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-o 编译结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Create product structure</span><br><span class="line"></span><br><span class="line">Process product packaging</span><br><span class="line"></span><br><span class="line"><span class="built_in">Run</span> custom shell<span class="built_in"> script </span><span class="string">&#x27;Check Pods Manifest.lock&#x27;</span></span><br><span class="line"></span><br><span class="line">Compile <span class="built_in">..</span>. 各个项目中的.m文件</span><br><span class="line"></span><br><span class="line">Link /Users/<span class="built_in">..</span>. 路径</span><br><span class="line"></span><br><span class="line">Copy <span class="built_in">..</span>. 静态文件</span><br><span class="line"></span><br><span class="line">Compile asset catalogs</span><br><span class="line"></span><br><span class="line">Compile Storyboard file <span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">Process info.plist</span><br><span class="line"></span><br><span class="line">Link Storyboards</span><br><span class="line"></span><br><span class="line"><span class="built_in">Run</span> custom shell<span class="built_in"> script </span><span class="string">&#x27;Embed Pods Frameworks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Run</span> custom shell<span class="built_in"> script </span><span class="string">&#x27;Copy Pods Resources&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">Touch GCDFetchFeed.app</span><br><span class="line"></span><br><span class="line">Sign GCDFetchFeed.app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">rootObject</span> <span class="operator">=</span> <span class="number">3</span>EE311301C4E1F0800103FA3 /* Project object */<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后根据这个 ID 找到 main 工程的定义。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Begin PBXProject section */</span></span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>EE311301C4E1F0800103FA3 <span class="comment">/* Project object */</span> = &#123;</span><br><span class="line"></span><br><span class="line">			isa = PBXProject;</span><br><span class="line"></span><br><span class="line">			<span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* End PBXProject section */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 targets 里会指向各个 taget 的定义</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">targets = (</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>EE311371C4E<span class="symbol">1F</span><span class="symbol">0800103F</span><span class="built_in">A3</span> <span class="comment">/* GCDFetchFeed */</span>,</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>EE311501C4E<span class="symbol">1F</span><span class="symbol">0800103F</span><span class="built_in">A3</span> <span class="comment">/* GCDFetchFeedTests */</span>,</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>EE<span class="symbol">3115B</span>1C4E<span class="symbol">1F</span><span class="symbol">0800103F</span><span class="built_in">A3</span> <span class="comment">/* GCDFetchFeedUITests */</span>,</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed <span class="emphasis">*/ = &#123;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">	isa = PBXNativeTarget;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /*</span> configuration list for PBXNativeTarget &quot;GCDFetchFeed&quot; </span><br><span class="line"></span><br><span class="line"><span class="code">	buildPhases = (</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		3EE311341C4E1F0800103FA3 /* Sources */,</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		3EE311351C4E1F0800103FA3 /* Frameworks */,</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		3EE311361C4E1F0800103FA3 /* Resources */,</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		DD33A716222617FAB49F1472 /* Copy Pods Resources </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	buildRules = (</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	dependencies = (</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	name = GCDFetchFeed;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	productName = GCDFetchFeed;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	productType = &quot;com.apple.product-type.application&quot;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h2 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h2><p>可以在 <a target="_blank" rel="noopener" href="https://code.woboq.org/llvm/clang/">llvm&#x2F;clang&#x2F; Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?time_continue=280&v=VqCkCDFLSsc">The Clang AST - a Tutorial - YouTube</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a target="_blank" rel="noopener" href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">TokensKind.def</a> 里有 Clang 定义的所有 Token。通过下面的命令可以输出所有 token 和所在文件具体位置</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -fmodules -E -Xclang -dump-tokens <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">annot_module_include ‘<span class="meta">#import <span class="string">&lt;Fo’ Loc= &lt;main.m:2:1&gt;</span>int ‘int’ [StartOfLine] Loc= <span class="string">&lt;main.m:5:1&gt;</span>identifier ‘main’ [LeadingSpace] Loc= <span class="string">&lt;main.m:5:5&gt;</span>l_paren ‘(‘ Loc= <span class="string">&lt;main.m:5:9&gt;</span>r_paren ‘)’ Loc= <span class="string">&lt;main.m:5:10&gt;</span>l_brace ‘&#123;‘ [LeadingSpace] Loc= <span class="string">&lt;main.m:5:12&gt;</span>at ‘@’ [StartOfLine] [LeadingSpace] Loc= <span class="string">&lt;main.m:6:5&gt;</span>identifier ‘autoreleasepool’ Loc= <span class="string">&lt;main.m:6:6&gt;</span>l_brace ‘&#123;‘ [LeadingSpace] Loc= <span class="string">&lt;main.m:6:22&gt;</span>identifier ‘NSString’ [StartOfLine] [LeadingSpace] Loc= <span class="string">&lt;main.m:7:9&gt;</span>star ‘*’ [LeadingSpace] Loc= <span class="string">&lt;main.m:7:18&gt;</span>identifier ‘a’ Loc= <span class="string">&lt;main.m:7:19&gt;</span>equal ‘=’ [LeadingSpace] Loc= <span class="string">&lt;main.m:7:21&gt;</span>at ‘@’ [LeadingSpace] Loc= <span class="string">&lt;main.m:7:23&gt;</span>string_literal ‘“aaa”‘ Loc= <span class="string">&lt;main.m:7:24&gt;</span>semi ‘;’ Loc= <span class="string">&lt;main.m:7:29&gt;</span>identifier ‘NSLog’ [StartOfLine] [LeadingSpace] Loc= <span class="string">&lt;main.m:8:9&gt;</span>l_paren ‘(‘ Loc= <span class="string">&lt;main.m:8:14&gt;</span>at ‘@’ Loc= <span class="string">&lt;main.m:8:15&gt;</span>string_literal ‘“hi %@”‘ Loc= <span class="string">&lt;main.m:8:16&gt;</span>comma ‘,’ Loc= <span class="string">&lt;main.m:8:23&gt;</span>identifier ‘a’ Loc= <span class="string">&lt;main.m:8:24&gt;</span>r_paren ‘)’ Loc= <span class="string">&lt;main.m:8:25&gt;</span>semi ‘;’ Loc= <span class="string">&lt;main.m:8:26&gt;</span>r_brace ‘&#125;’ [StartOfLine] [LeadingSpace] Loc= <span class="string">&lt;main.m:9:5&gt;</span>return ‘return’ [StartOfLine] [LeadingSpace] Loc= <span class="string">&lt;main.m:10:5&gt;</span>numeric_constant ‘0’ [LeadingSpace] Loc= <span class="string">&lt;main.m:10:12&gt;</span>semi ‘;’ Loc= <span class="string">&lt;main.m:10:13&gt;</span>r_brace ‘&#125;’ [StartOfLine] Loc= <span class="string">&lt;main.m:11:1&gt;</span>eof ‘’ Loc= <span class="string">&lt;main.m:11:2&gt;</span><span class="string">&lt;/main.m:11:2&gt;</span><span class="string">&lt;/main.m:11:1&gt;</span><span class="string">&lt;/main.m:10:13&gt;</span><span class="string">&lt;/main.m:10:12&gt;</span><span class="string">&lt;/main.m:10:5&gt;</span><span class="string">&lt;/main.m:9:5&gt;</span><span class="string">&lt;/main.m:8:26&gt;</span><span class="string">&lt;/main.m:8:25&gt;</span><span class="string">&lt;/main.m:8:24&gt;</span><span class="string">&lt;/main.m:8:23&gt;</span><span class="string">&lt;/main.m:8:16&gt;</span><span class="string">&lt;/main.m:8:15&gt;</span><span class="string">&lt;/main.m:8:14&gt;</span><span class="string">&lt;/main.m:8:9&gt;</span><span class="string">&lt;/main.m:7:29&gt;</span><span class="string">&lt;/main.m:7:24&gt;</span><span class="string">&lt;/main.m:7:23&gt;</span><span class="string">&lt;/main.m:7:21&gt;</span><span class="string">&lt;/main.m:7:19&gt;</span><span class="string">&lt;/main.m:7:18&gt;</span><span class="string">&lt;/main.m:7:9&gt;</span><span class="string">&lt;/main.m:6:22&gt;</span><span class="string">&lt;/main.m:6:6&gt;</span><span class="string">&lt;/main.m:6:5&gt;</span><span class="string">&lt;/main.m:5:12&gt;</span><span class="string">&lt;/main.m:5:10&gt;</span><span class="string">&lt;/main.m:5:9&gt;</span><span class="string">&lt;/main.m:5:5&gt;</span><span class="string">&lt;/main.m:5:1&gt;</span><span class="string">&lt;/main.m:2:1&gt;</span> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc&#x3D;<a href="main.m:11:1">main.m:11:1</a> 这个样的具体位置。</p>
<p>接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。打印语法树的命令</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump <span class="selector-tag">main</span><span class="selector-class">.m</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TranslationUnitDecl 0x7fa80f018ad0 &lt;&lt;<span class="string">invalid sloc=&quot;&quot;&gt;&gt;  &lt;invalid</span> sloc=<span class="string">&quot;&quot;</span>&gt;|-TypedefDecl 0x7fa80f018fc8 &lt;&lt;<span class="string">invalid sloc=&quot;&quot;&gt;&gt; &lt;invalid</span> sloc=<span class="string">&quot;&quot;</span>&gt;implicit **int128_t ‘**int128’</span><br><span class="line">| `-BuiltinType 0x7fa80f018d20 <span class="string">&#x27;__int128&#x27;</span> |-TypedefDecl 0x7fa80f019028 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __uint128_t <span class="string">&#x27;unsigned __int128&#x27;</span> |`-BuiltinType 0x7fa80f018d40 ‘unsigned **int128’</span><br><span class="line">|-TypedefDecl 0x7fa80f0190b8 &lt;&lt;<span class="string">invalid sloc=&quot;&quot;&gt;&gt; &lt;invalid</span> sloc=<span class="string">&quot;&quot;</span>&gt;implicit SEL ‘SEL *‘</span><br><span class="line">| `-PointerType 0x7fa80f019080 ‘SEL *‘</span><br><span class="line">|  `-BuiltinType 0x7fa80f018f30 <span class="string">&#x27;SEL&#x27;</span> |-TypedefDecl 0x7fa80f019198 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit <span class="built_in">id</span> <span class="string">&#x27;id&#x27;</span> |`-ObjCObjectPointerType 0x7fa80f019140 ‘<span class="built_in">id</span>’ imported</span><br><span class="line">|  `-ObjCObjectType 0x7fa80f019110 <span class="string">&#x27;id&#x27;</span> imported |-TypedefDecl 0x7fa80f019278 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit Class <span class="string">&#x27;Class&#x27;</span> |`-ObjCObjectPointerType 0x7fa80f019220 ‘Class’</span><br><span class="line">| `-ObjCObjectType 0x7fa80f0191f0 ‘Class’</span><br><span class="line">|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;&lt;<span class="string">invalid sloc=&quot;&quot;&gt;&gt; &lt;invalid</span> sloc=<span class="string">&quot;&quot;</span>&gt;implicit Protocol</span><br><span class="line">|-TypedefDecl 0x7fa80f019618 &lt;&lt;<span class="string">invalid sloc=&quot;&quot;&gt;&gt; &lt;invalid</span> sloc=<span class="string">&quot;&quot;</span>&gt;implicit &lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt;**NSConstantString ‘struct **NSConstantString_tag’</span><br><span class="line">| `-RecordType 0x7fa80f019430 ‘struct **NSConstantString_tag’</span><br><span class="line">|  `-Record 0x7fa80f019390 <span class="string">&#x27;__NSConstantString_tag&#x27;</span> |-TypedefDecl 0x7fa80f0196a8 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_ms_va_list <span class="string">&#x27;char *&#x27;</span> |`-PointerType 0x7fa80f019670 ‘char *‘</span><br><span class="line">|  `-BuiltinType 0x7fa80f018b60 <span class="string">&#x27;char&#x27;</span> |-TypedefDecl 0x7fa80f047978 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_va_list <span class="string">&#x27;struct __va_list_tag [1]&#x27;</span> |`-ConstantArrayType 0x7fa80f047920 ‘struct **va_list_tag [1]’ 1</span><br><span class="line">| `-RecordType 0x7fa80f0197a0 ‘struct **va_list_tag’</span><br><span class="line">|  `-Record 0x7fa80f0196f8 <span class="string">&#x27;__va_list_tag&#x27;</span> |-ImportDecl 0x7fa80f0486b0 &lt;main.m:2:1&gt; col:1 implicit Foundation |-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main <span class="string">&#x27;int ()&#x27;</span> |`-CompoundStmt 0x7fa80f393998  &lt;col:12, line:11:1=<span class="string">&quot;&quot;</span>&gt;| |-ObjCAutoreleasePoolStmt 0x7fa80f393950  &lt;line:6:5, line:9:5=<span class="string">&quot;&quot;</span>&gt;| | `-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt; | | |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt; | | |`-VarDecl 0x7fa80f3a3580 &lt;col:9, col:24=<span class="string">&quot;&quot;</span>&gt;col:19 used a ‘NSString &lt;/col:9,&gt;&lt;/line:6:5,&gt;&lt;/col:12,&gt;*‘ cinit</span><br><span class="line">| | |  `-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; <span class="string">&#x27;NSString *&#x27;</span> | | |`-StringLiteral 0x7fa80f3a3618 &lt;col:24&gt;‘char [4]’ lvalue “aaa”</span><br><span class="line">| |  `-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; <span class="string">&#x27;void&#x27;</span> | | |-ImplicitCastExpr 0x7fa80f3938a8 &lt;col:9&gt; <span class="string">&#x27;void (*)(id, ...)&#x27;</span> &lt;FunctionToPointerDecay&gt; | | |`-DeclRefExpr 0x7fa80f3a3b50 &lt;col:9&gt;‘void (<span class="built_in">id</span>, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (<span class="built_in">id</span>, …)’</span><br><span class="line">| | |-ImplicitCastExpr 0x7fa80f3938f8 &lt;col:15, col:16=<span class="string">&quot;&quot;</span>&gt;‘<span class="built_in">id</span>’:’<span class="built_in">id</span>’  &lt;bitcast&gt;| | | `-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; <span class="string">&#x27;NSString *&#x27;</span> | | |`-StringLiteral 0x7fa80f3a3bb8 &lt;col:16&gt;‘char [6]’ lvalue “hi %@”</span><br><span class="line">| |  `-ImplicitCastExpr 0x7fa80f393910 &lt;col:24&gt; <span class="string">&#x27;NSString *&#x27;</span> &lt;LValueToRValue&gt; | |`-DeclRefExpr 0x7fa80f393820 &lt;col:24&gt;‘NSString *‘ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString *‘</span><br><span class="line">|  `-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt; |`-IntegerLiteral 0x7fa80f393960 &lt;col:12&gt;‘int’ 0</span><br><span class="line">`- &lt;undeserialized declarations=<span class="string">&quot;&quot;</span>&gt;&lt;/undeserialized&gt;&lt;/col:12&gt;&lt;/col:24&gt;&lt;/col:16&gt;&lt;/bitcast&gt;&lt;/col:15,&gt;&lt;/col:9&gt;&lt;/col:24&gt;&lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt;&lt;/invalid&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</p>
<p>clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</p>
<p>可以通过 clang –analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib &#x2F; StaticAnalyzer &#x2F; Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debug</span>.ConfigDumper Dump config <span class="keyword">table</span></span><br><span class="line"><span class="keyword">debug</span>.DumpCFG Display Control-Flow Graphs</span><br><span class="line"><span class="keyword">debug</span>.DumpCallGraph Display <span class="keyword">Call</span> Graph</span><br><span class="line"><span class="keyword">debug</span>.DumpCalls Print calls <span class="keyword">as</span> they are traversed <span class="keyword">by</span> the engine</span><br><span class="line"><span class="keyword">debug</span>.DumpDominators Print the dominance tree <span class="keyword">for</span> a given CFG</span><br><span class="line"><span class="keyword">debug</span>.DumpLiveVars Print results <span class="keyword">of</span> live variable analysis</span><br><span class="line"><span class="keyword">debug</span>.DumpTraversal Print branch conditions <span class="keyword">as</span> they are traversed <span class="keyword">by</span> the engine</span><br><span class="line"><span class="keyword">debug</span>.ExprInspection <span class="keyword">Check</span> the analyzer’s understanding <span class="keyword">of</span> expressions</span><br><span class="line"><span class="keyword">debug</span>.Stats Emit warnings <span class="keyword">with</span> analyzer <span class="keyword">statistics</span></span><br><span class="line"><span class="keyword">debug</span>.TaintTest Mark tainted symbols <span class="keyword">as</span> such.</span><br><span class="line"><span class="keyword">debug</span>.ViewCFG <span class="keyword">View</span> Control-Flow Graphs <span class="keyword">using</span> GraphViz</span><br><span class="line"><span class="keyword">debug</span>.ViewCallGraph <span class="keyword">View</span> <span class="keyword">Call</span> Graph <span class="keyword">using</span> GraphViz</span><br><span class="line"><span class="keyword">debug</span>.ViewExplodedGraph <span class="keyword">View</span> Exploded Graphs <span class="keyword">using</span> GraphViz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</p>
<p>clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</p>
<p>编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</p>
<p>clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</p>
<p>整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：<a target="_blank" rel="noopener" href="http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf">http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf</a> 在clang里的具体实现代码可以查看这两个文件 <a target="_blank" rel="noopener" href="https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html">MemRegion.h</a>和 <a target="_blank" rel="noopener" href="https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html">RegionStore.cpp</a> 。</p>
<p>下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	a = b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的 AST 以及 CFG</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="comment">----------------AST-------------------</span></span><br><span class="line"></span><br><span class="line"># clang -cc1 -ast-dump</span><br><span class="line"></span><br><span class="line">TranslationUnitDecl <span class="number">0xc75b450</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</span><br><span class="line"></span><br><span class="line">|-TypedefDecl <span class="number">0xc75b740</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list <span class="string">&#x27;char *&#x27;</span></span><br><span class="line"></span><br><span class="line">`-FunctionDecl <span class="number">0xc75b7b0</span> &lt;test.cpp:<span class="number">1</span>:<span class="number">1</span>, <span class="type">line</span>:<span class="number">7</span>:<span class="number">1</span>&gt; <span class="type">line</span>:<span class="number">1</span>:<span class="number">5</span> main <span class="string">&#x27;int (void)&#x27;</span></span><br><span class="line"></span><br><span class="line">  `-CompoundStmt <span class="number">0xc75b978</span> &lt;<span class="type">line</span>:<span class="number">2</span>:<span class="number">1</span>, <span class="type">line</span>:<span class="number">7</span>:<span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line">    |-DeclStmt <span class="number">0xc75b870</span> &lt;<span class="type">line</span>:<span class="number">3</span>:<span class="number">2</span>, col:<span class="number">7</span>&gt;</span><br><span class="line"></span><br><span class="line">    | `-VarDecl <span class="number">0xc75b840</span> &lt;col:<span class="number">2</span>, col:<span class="number">6</span>&gt; col:<span class="number">6</span> used a <span class="string">&#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line">    |-DeclStmt <span class="number">0xc75b8d8</span> &lt;<span class="type">line</span>:<span class="number">4</span>:<span class="number">2</span>, col:<span class="number">12</span>&gt;</span><br><span class="line"></span><br><span class="line">    | `-VarDecl <span class="number">0xc75b890</span> &lt;col:<span class="number">2</span>, col:<span class="number">10</span>&gt; col:<span class="number">6</span> used b <span class="string">&#x27;int&#x27;</span> cinit</span><br><span class="line"></span><br><span class="line">    |   `-IntegerLiteral <span class="number">0xc75b8c0</span> &lt;col:<span class="number">10</span>&gt; <span class="string">&#x27;int&#x27;</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">    |-BinaryOperator <span class="number">0xc75b928</span> &lt;<span class="type">line</span>:<span class="number">5</span>:<span class="number">2</span>, col:<span class="number">6</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue <span class="string">&#x27;=&#x27;</span></span><br><span class="line"></span><br><span class="line">    | |-DeclRefExpr <span class="number">0xc75b8e8</span> &lt;col:<span class="number">2</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue Var <span class="number">0xc75b840</span> <span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line">    | `-ImplicitCastExpr <span class="number">0xc75b918</span> &lt;col:<span class="number">6</span>&gt; <span class="string">&#x27;int&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class="line"></span><br><span class="line">    |   `-DeclRefExpr <span class="number">0xc75b900</span> &lt;col:<span class="number">6</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue Var <span class="number">0xc75b890</span> <span class="string">&#x27;b&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">    `-ReturnStmt <span class="number">0xc75b968</span> &lt;<span class="type">line</span>:<span class="number">6</span>:<span class="number">2</span>, col:<span class="number">9</span>&gt;</span><br><span class="line"></span><br><span class="line">      `-ImplicitCastExpr <span class="number">0xc75b958</span> &lt;col:<span class="number">9</span>&gt; <span class="string">&#x27;int&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class="line"></span><br><span class="line">        `-DeclRefExpr <span class="number">0xc75b940</span> &lt;col:<span class="number">9</span>&gt; <span class="string">&#x27;int&#x27;</span> lvalue Var <span class="number">0xc75b840</span> <span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">----------------CFG-------------------</span></span><br><span class="line"></span><br><span class="line"># clang -cc1 -<span class="keyword">analyze</span> -analyzer-checker=<span class="keyword">debug</span>.DumpCFG</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line"></span><br><span class="line"> [B2 (ENTRY)]</span><br><span class="line"></span><br><span class="line">   Succs (<span class="number">1</span>): B1</span><br><span class="line"></span><br><span class="line"> [B1]</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>: <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>: <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span>: b</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span>: [B1<span class="number">.4</span>] (ImplicitCastExpr, LValueToRValue, <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">   <span class="number">6</span>: a</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>: [B1<span class="number">.6</span>] = [B1<span class="number">.5</span>]</span><br><span class="line"></span><br><span class="line">   <span class="number">8</span>: a</span><br><span class="line"></span><br><span class="line">   <span class="number">9</span>: [B1<span class="number">.8</span>] (ImplicitCastExpr, LValueToRValue, <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">10</span>: <span class="keyword">return</span> [B1<span class="number">.9</span>];</span><br><span class="line"></span><br><span class="line">   Preds (<span class="number">1</span>): B2</span><br><span class="line"></span><br><span class="line">   Succs (<span class="number">1</span>): B0</span><br><span class="line"></span><br><span class="line"> [B0 (<span class="keyword">EXIT</span>)]</span><br><span class="line"></span><br><span class="line">   Preds (<span class="number">1</span>): B1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Tooling.html">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/RAVFrontendAction.html">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LibTooling.html">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LibASTMatchers.html">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<h2 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h2><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li>**block 和 **weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush &#x2F; Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<h2 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h2><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h3 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h3><p>可以查看 NSLog 的用法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="type">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="built_in">NS_NO_TAIL_CALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Marks APIs which format strings by taking a format string and optional varargs as arguments</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NS_FORMAT_FUNCTION)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NS_FORMAT_FUNCTION(F,A)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h3><p>在编译过程中能够提示开发者该方法或者属性已经被弃用</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)preMethod:( NSString *)<span class="built_in">string</span> __attribute__((<span class="keyword">deprecated</span>(<span class="string">&quot;preMethod已经被弃用，请使用newMethod&quot;</span>)));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)deprecatedMethod DEPRECATED_ATTRIBUTE; <span class="comment">//也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-””-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-””-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced&#x3D;m,deprecated&#x3D;n, obsoleted&#x3D;o,message&#x3D;”” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced&#x3D;m,deprecated&#x3D;n, obsoleted&#x3D;o,message&#x3D;”” <strong>VA_ARGS</strong>))) 指明使用版本范围</h3><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)<span class="keyword">method</span> __<span class="title function_">attribute__</span><span class="params">((availability(ios,introduced=3_0,<span class="keyword">deprecated</span>=6_0,obsoleted=7_0,message=&quot;iOS3到iOS7版本可用，iOS7不能用&quot;)</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h3><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h3 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h3><p>没有被使用也不报警告</p>
<h3 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h3><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h3 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message&#x3D;_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message&#x3D;_msg)))</h3><p>OC 的方法不能在 Swift 中使用。</p>
<h3 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h3><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> onExit \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    rac_keywordify \</span><br><span class="line"></span><br><span class="line">    <span class="function">__strong rac_cleanupBlock_t <span class="title">metamacro_concat</span><span class="params">(rac_exitBlock_, __LINE__)</span> __<span class="title">attribute__</span><span class="params">((cleanup(rac_executeCleanupBlock), unused))</span> </span>= ^</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">rac_executeCleanupBlock</span> <span class="params">(__strong rac_cleanupBlock_t *block)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    (*block)();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (property !<span class="operator">=</span> NULL) &#123;</span><br><span class="line"></span><br><span class="line">		rac_propertyAttributes *<span class="keyword">attributes</span> <span class="operator">=</span> rac_copyPropertyAttributes(property)<span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">		if (<span class="keyword">attributes</span> !<span class="operator">=</span> NULL) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="title">@onExit</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">free</span>(<span class="keyword">attributes</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			&#125;<span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			BOOL isObject <span class="operator">=</span> <span class="keyword">attributes</span>-&gt;objectClass !<span class="operator">=</span> nil || strstr(<span class="keyword">attributes</span>-&gt;<span class="keyword">type</span><span class="punctuation">,</span> <span class="title">@encode</span>(id)) <span class="operator">=</span><span class="operator">=</span> <span class="keyword">attributes</span>-&gt;<span class="keyword">type</span><span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			BOOL isProtocol <span class="operator">=</span> <span class="keyword">attributes</span>-&gt;objectClass <span class="operator">=</span><span class="operator">=</span> NSClassFromString(@<span class="string">&quot;Protocol&quot;</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			BOOL isBlock <span class="operator">=</span> strcmp(<span class="keyword">attributes</span>-&gt;<span class="keyword">type</span><span class="punctuation">,</span> <span class="title">@encode</span>(<span class="type">void</span>(^)())) <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			BOOL isWeak <span class="operator">=</span> <span class="keyword">attributes</span>-&gt;<span class="keyword">weak</span><span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">			shouldAddDeallocObserver <span class="operator">=</span> isObject &amp;&amp; isWeak &amp;&amp; <span class="title">!isBlock</span> &amp;&amp; <span class="title">!isProtocol</span><span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h3 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h3><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">__attribute__</span>((overloadable)) void <span class="built_in">printArgument</span>(int number)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;Add Int %i&quot;, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">__attribute__</span>((overloadable)) void <span class="built_in">printArgument</span>(NSString *number)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;Add NSString %@&quot;, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">__attribute__</span>((overloadable)) void <span class="built_in">printArgument</span>(NSNumber *number)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;Add NSNumber %@&quot;, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h3><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h3 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h3><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h3 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h3><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h3 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h3><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h3 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h3><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h2 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h2><p>先看看这个</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Wdeprecated-declarations&quot;</span></span></span><br><span class="line"></span><br><span class="line">        sizeLabel = [<span class="keyword">self</span> sizeWithFont:font constrainedToSize:size lineBreakMode:<span class="built_in">NSLineBreakByWordWrapping</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push&#x2F;pop 可以灵活的控制代码块的编译选项。</p>
<h2 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h2><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js &#x2F; ruby binding，还有 Objective-C的开源库 <a target="_blank" rel="noopener" href="https://github.com/macmade/ClangKit">GitHub - macmade&#x2F;ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install clang</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim: set fileencoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clang.cindex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asciitree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">node_children</span>(<span class="params">node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_node</span>(<span class="params">node</span>):</span><br><span class="line"></span><br><span class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</span><br><span class="line"></span><br><span class="line">    kind = <span class="built_in">str</span>(node.kind)[<span class="built_in">str</span>(node.kind).index(<span class="string">&#x27;.&#x27;</span>)+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(kind, text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: dump_ast.py [header file name]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">clang.cindex.Config.set_library_file(<span class="string">&#x27;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = clang.cindex.Index.create()</span><br><span class="line"></span><br><span class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;objective-c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> asciitree.draw_tree(translation_unit.cursor,</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">lambda</span> n: <span class="built_in">list</span>(n.get_children()),</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">lambda</span> n: <span class="string">&quot;%s (%s)&quot;</span> % (n.spelling <span class="keyword">or</span> n.displayname, <span class="built_in">str</span>(n.kind).split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基于语法树的分析还可以针对字符串做加密。</p>
<h2 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h2><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者 Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~&#x2F;llvm&#x2F;tools&#x2F;clang&#x2F;tools&#x2F; 在这了可以创建自己的 clang 工具。这里有个范例： <a target="_blank" rel="noopener" href="https://github.com/objcio/issue-6-compiler-tool">GitHub - objcio&#x2F;issue-6-compiler-tool: Example code for a standalone clang&#x2F;llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface <span class="type">Observer</span></span><br><span class="line"></span><br><span class="line">+ (instance<span class="keyword">type</span>)observerWithTarget:(id)target action:(<span class="type">SEL</span>)selector;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></span><br><span class="line"></span><br><span class="line">virtual <span class="keyword">bool</span> VisitObjCMessageExpr(ObjCMessageExpr *E) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</span><br><span class="line"></span><br><span class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</span><br><span class="line"></span><br><span class="line">    Selector Sel = E-&gt;getSelector();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> TypeName = ReceiverType.getAsString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> SelName = Sel.getAsString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TypeName == <span class="string">&quot;Observer&quot;</span> &amp;&amp; SelName == <span class="string">&quot;observerWithTarget:action:&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</span><br><span class="line"></span><br><span class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</span><br><span class="line"></span><br><span class="line">      Selector Sel = SelExpr-&gt;getSelector();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</span><br><span class="line"></span><br><span class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</span><br><span class="line"></span><br><span class="line">          errs() &lt;&lt; <span class="string">&quot;Warning: class &quot;</span> &lt;&lt; TypeName &lt;&lt; <span class="string">&quot; does not implement selector &quot;</span> &lt;&lt; Sel.getAsString() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">          SourceLocation Loc = E-&gt;getExprLoc();</span><br><span class="line"></span><br><span class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</span><br><span class="line"></span><br><span class="line">          errs() &lt;&lt; <span class="string">&quot;in &quot;</span> &lt;&lt; PLoc.getFilename() &lt;&lt; <span class="string">&quot; &lt;&quot;</span> &lt;&lt; PLoc.getLine() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; PLoc.getColumn() &lt;&lt; <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ClangPlugin"><a href="#ClangPlugin" class="headerlink" title="ClangPlugin"></a>ClangPlugin</h2><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm&#x2F;tools&#x2F;clang&#x2F;tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a target="_blank" rel="noopener" href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a target="_blank" rel="noopener" href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a target="_blank" rel="noopener" href="http://blog.cnbang.net/tech/3219/">如何动态调用 C 函数 « bang’s blog</a> 。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.cnbang.net/tech/2808/">JSPatch实现原理详解 « bang’s blog</a></li>
<li><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/6c756ce76758">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=2651112856&idx=1&sn=b2c74c62a10b4c9a4e7538d1ad7eb739">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>收集一些如何使用 clang 库的例子：<a target="_blank" rel="noopener" href="https://github.com/loarabia/Clang-tutorial">GitHub - loarabia&#x2F;Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a target="_blank" rel="noopener" href="http://clang-analyzer.llvm.org/xcode.html">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a target="_blank" rel="noopener" href="https://github.com/harlanhaskins/LLVMSwift">GitHub - harlanhaskins&#x2F;LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h2 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h2><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C&#x2F;OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;hi!&quot;</span>)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">swiftc toy.swift</span><br><span class="line"></span><br><span class="line">./toy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成检查 AST</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">swiftc </span>-dump-ast toy.<span class="keyword">swift</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>

<p>可以还原之前函数名</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">swiftc <span class="punctuation">-</span>emit<span class="punctuation">-</span>silgen toy.swift <span class="string">| xcrun swift-demangle</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>llvm ir 和汇编的生成</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">swiftc </span>-emit-ir toy.<span class="keyword">swift</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">swiftc </span>-emit-assembly toy.<span class="keyword">swift</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>

<p>生成可执行的脚本</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun -sdk macosx <span class="keyword">swiftc </span>toy.<span class="keyword">swift </span>-o toy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h2><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h3 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h3><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h3 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h3><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 **TEXT 代码段和 **DATA 数据段两种。</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h2 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h2><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">DEVELOPER_DIR</span>=/Applications/Xcode.app/Contents/Developer</span><br><span class="line"></span><br><span class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h2><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h3 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h3><p>再通过一个例子来分析下：<br>这次用 xcrun 来</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">xcrun clang -v</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先创建一个test.c的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">touch</span> test.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编辑里面的内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vi test.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hi there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译运行，没有起名默认为 a.out</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun clang test<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">./<span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun clang -S -o - <span class="keyword">test</span>.c | <span class="keyword">open</span> -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">.section	__TEXT,__text,regular,pure_instructions</span></span><br><span class="line"></span><br><span class="line"><span class="title">.macosx_version_min 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="title">.globl	_main</span></span><br><span class="line"></span><br><span class="line"><span class="title">.align	4, 0x90</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_main:                                  <span class="comment">## @main</span></span><br><span class="line"></span><br><span class="line">	.cfi_startproc</span><br><span class="line"></span><br><span class="line"><span class="comment">## BB#0:</span></span><br><span class="line"></span><br><span class="line">	pushq	<span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line">Ltmp0:</span><br><span class="line"></span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line"></span><br><span class="line">Ltmp1:</span><br><span class="line"></span><br><span class="line">	.cfi_offset <span class="variable">%rbp</span>, -<span class="number">16</span></span><br><span class="line"></span><br><span class="line">	movq	<span class="variable">%rsp</span>, <span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line">Ltmp2:</span><br><span class="line"></span><br><span class="line">	.cfi_def_cfa_register <span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line">	subq	<span class="variable">$3</span>2, <span class="variable">%rsp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in &#x2F; out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">leaq	L_.str(%rip), %rax</span><br><span class="line"></span><br><span class="line">movl	$0, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">movl	%edi, <span class="number">-8</span>(%rbp)</span><br><span class="line"></span><br><span class="line">movq	%rsi, <span class="number">-16</span>(%rbp)</span><br><span class="line"></span><br><span class="line">movq	%rax, %rdi</span><br><span class="line"></span><br><span class="line">movb	$0, %al</span><br><span class="line"></span><br><span class="line">callq	_printf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>leap 会将 L*.str 这个指针加载到 rax 寄存器里。可以看看 L*.str 的定义</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L_.<span class="params">str:</span>                                 <span class="comment">## @.str</span></span><br><span class="line"></span><br><span class="line">	.asciz	<span class="string">&quot;hi there<span class="char escape_">\n</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xorl	<span class="variable">%ecx</span>, <span class="variable">%ecx</span></span><br><span class="line"></span><br><span class="line">movl	<span class="variable">%eax</span>, -<span class="number">20</span>(<span class="variable">%rbp</span>)         <span class="comment">## 4-byte Spill</span></span><br><span class="line"></span><br><span class="line">movl	<span class="variable">%ecx</span>, <span class="variable">%eax</span></span><br><span class="line"></span><br><span class="line">addq	<span class="variable">$3</span>2, <span class="variable">%rsp</span></span><br><span class="line"></span><br><span class="line">popq	<span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line">retq</span><br><span class="line"></span><br><span class="line">.cfi_endproc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>xorl %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="string">.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"></span><br><span class="line">L_.str:                                 <span class="comment">## @.str</span></span><br><span class="line"></span><br><span class="line">	<span class="string">.asciz</span>	<span class="string">&quot;hi there\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.subsections_via_symbols</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun size -<span class="attribute">x</span> -l -m <span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Segment</span> __PAGEZERO: <span class="number">0</span>x100000000 (vmaddr <span class="number">0</span>x0 fileoff <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">Segment</span> __TEXT: <span class="number">0</span>x1000 (vmaddr <span class="number">0</span>x100000000 fileoff <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __text: <span class="number">0</span>x34 (addr <span class="number">0</span>x100000f50 offset <span class="number">3920</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __stubs: <span class="number">0</span>x6 (addr <span class="number">0</span>x100000f84 offset <span class="number">3972</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __stub_helper: <span class="number">0</span>x1a (addr <span class="number">0</span>x100000f8c offset <span class="number">3980</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __cstring: <span class="number">0</span>xa (addr <span class="number">0</span>x100000fa6 offset <span class="number">4006</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __unwind_info: <span class="number">0</span>x48 (addr <span class="number">0</span>x100000fb0 offset <span class="number">4016</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">total</span> <span class="number">0</span>xa6</span><br><span class="line"></span><br><span class="line"><span class="attribute">Segment</span> __DATA: <span class="number">0</span>x1000 (vmaddr <span class="number">0</span>x100001000 fileoff <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __nl_symbol_ptr: <span class="number">0</span>x10 (addr <span class="number">0</span>x100001000 offset <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">Section</span> __la_symbol_ptr: <span class="number">0</span>x8 (addr <span class="number">0</span>x100001010 offset <span class="number">4112</span>)</span><br><span class="line"></span><br><span class="line">	<span class="attribute">total</span> <span class="number">0</span>x18</span><br><span class="line"></span><br><span class="line"><span class="attribute">Segment</span> __LINKEDIT: <span class="number">0</span>x1000 (vmaddr <span class="number">0</span>x100002000 fileoff <span class="number">8192</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">total</span> <span class="number">0</span>x100003000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li>**stubs 和 **stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c &#x3D; “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun otool -s __<span class="built_in">TEXT</span> __<span class="built_in">text</span> a.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>.out:</span><br><span class="line"></span><br><span class="line"><span class="attribute">Contents</span> of (__TEXT,__text) section</span><br><span class="line"></span><br><span class="line"><span class="attribute">0000000100000f50</span>	<span class="number">55</span> <span class="number">48</span> <span class="number">89</span> e5 <span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span> <span class="number">48</span> <span class="number">8</span>d <span class="number">05</span> <span class="number">47</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> c7 </span><br><span class="line"></span><br><span class="line"><span class="attribute">0000000100000f60</span>	<span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">89</span> <span class="number">7</span>d f8 <span class="number">48</span> <span class="number">89</span> <span class="number">75</span> f0 <span class="number">48</span> <span class="number">89</span> c7 </span><br><span class="line"></span><br><span class="line"><span class="attribute">0000000100000f70</span>	b0 <span class="number">00</span> e8 <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">31</span> c9 <span class="number">89</span> <span class="number">45</span> ec <span class="number">89</span> c8 <span class="number">48</span> <span class="number">83</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">0000000100000f80</span>	c4 <span class="number">20</span> <span class="number">5</span>d c3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个返回的内容很难读，加个 - v 就可以查看反汇编代码了， -s **TEXT **text 有个缩写 -t</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun otool -v -t <span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a.out:</span><br><span class="line"></span><br><span class="line">(__TEXT<span class="punctuation">,</span>__text) <span class="keyword">section</span></span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">50</span>	pushq	<span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">51</span>	movq	<span class="variable">%rsp</span><span class="punctuation">,</span> <span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">54</span>	subq	$<span class="number">0x20</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">58</span>	leaq	<span class="number">0x47</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">5</span>f	movl	$<span class="number">0x0</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="variable">%rbp</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">66</span>	movl	<span class="variable">%edi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">69</span>	movq	<span class="variable">%rsi</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">6</span>d	movq	<span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">70</span>	movb	$<span class="number">0x0</span><span class="punctuation">,</span> <span class="variable">%al</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">72</span>	callq	<span class="number">0x100000f84</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">77</span>	xorl	<span class="variable">%ecx</span><span class="punctuation">,</span> <span class="variable">%ecx</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">79</span>	movl	<span class="variable">%eax</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="variable">%rbp</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">7</span><span class="keyword">c</span>	movl	<span class="variable">%ecx</span><span class="punctuation">,</span> <span class="variable">%eax</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">7</span>e	addq	$<span class="number">0x20</span><span class="punctuation">,</span> <span class="variable">%rsp</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">82</span>	popq	<span class="variable">%rbp</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f<span class="number">83</span>	retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">otool -v -h <span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Mach</span> header</span><br><span class="line"></span><br><span class="line">      <span class="attribute">magic</span> cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"></span><br><span class="line"><span class="attribute">MH_MAGIC_64</span>  X86_64        <span class="literal">ALL</span> LIB64     EXECUTE    <span class="number">15</span>       <span class="number">1200</span>   NOUNDEFS DYLDLINK TWOLEVEL PIE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mach_header 结构体</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct mach_header &#123;</span><br><span class="line"></span><br><span class="line">  uint32_t      magic<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  cpu_type_t    cputype<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  cpu_subtype_t cpusubtype<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t      filetype<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t      ncmds<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t      sizeofcmds<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t      flags<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">otool -v -l a.<span class="keyword">out</span> | <span class="keyword">open</span> -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加载命令结构体</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct segment_command &#123;</span><br><span class="line"></span><br><span class="line">  uint32_t  cmd<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  cmdsize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  char      segname[<span class="number">16</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  vmaddr<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  vmsize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  fileoff<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  filesize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  vm_prot_t maxprot<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  vm_prot_t initprot<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  nsects<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  uint32_t  flags<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 **TEXT **text 的section的内容</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Section</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">sectname</span> __text</span><br><span class="line"></span><br><span class="line">   <span class="attribute">segname</span> __TEXT</span><br><span class="line"></span><br><span class="line">      <span class="attribute">addr</span> <span class="number">0</span>x0000000100000f50</span><br><span class="line"></span><br><span class="line">      <span class="attribute">size</span> <span class="number">0</span>x0000000000000034</span><br><span class="line"></span><br><span class="line">    <span class="attribute">offset</span> <span class="number">3920</span></span><br><span class="line"></span><br><span class="line">     <span class="attribute">align</span> <span class="number">2</span>^<span class="number">4</span> (<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="attribute">reloff</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">nreloc</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">type</span> S_REGULAR</span><br><span class="line"></span><br><span class="line"><span class="attribute">attributes</span> PURE_INSTRUCTIONS SOME_INSTRUCTIONS</span><br><span class="line"></span><br><span class="line"> <span class="attribute">reserved1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="attribute">reserved2</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)say;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Foo.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)say</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;hi there again!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SayHi.m</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import &quot;Foo.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> *argv[]</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        Foo *foo = [[Foo alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">        [<span class="meta">foo say</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先编译多个文件</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun clang -<span class="keyword">c</span> Foo.m</span><br><span class="line"></span><br><span class="line">xcrun clang -<span class="keyword">c</span> SayHi.m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun --<span class="keyword">show</span>-sdk-path`/<span class="keyword">System</span>/<span class="keyword">Library</span>/Frameworks/Foundation.framework/Foundation</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h3><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook 放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a target="_blank" rel="noopener" href="http://dev.qq.com/topic/5791da152168f2690e72daa4">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a target="_blank" rel="noopener" href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C">MyArticles&#x2F;iOS冰与火之歌 at master · zhengmin1989&#x2F;MyArticles · GitHub</a></li>
<li>玩出新花样： <a target="_blank" rel="noopener" href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a target="_blank" rel="noopener" href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h2 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h2><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> SayHi.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _OBJC_CLASS<span class="number">_</span><span class="variable">$_Foo</span></span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _objc_autoreleasePoolPop</span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _objc_autoreleasePoolPush</span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _objc_msgSend</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> (__TEXT,__<span class="type">text</span>) <span class="keyword">external</span> _main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 **TEXT,**text section</li>
</ul>
<p> </p>
<p>再看看 Foo</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> Foo.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _NSLog</span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _OBJC_CLASS<span class="number">_</span><span class="variable">$_NSObject</span></span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> _OBJC_METACLASS<span class="number">_</span><span class="variable">$_NSObject</span></span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> ___CFConstantStringClassReference</span><br><span class="line"></span><br><span class="line">                 (undefined) <span class="keyword">external</span> __objc_empty_cache</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> (__TEXT,__<span class="type">text</span>) non-external -[Foo say]</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000060</span> (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO<span class="number">_</span><span class="variable">$_Foo</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000000000</span>a8 (__DATA,__objc_const) non-external l_OBJC<span class="number">_</span><span class="variable">$_INSTANCE_METHODS_Foo</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000000000</span>c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO<span class="number">_</span><span class="variable">$_Foo</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000110</span> (__DATA,__objc_data) <span class="keyword">external</span> _OBJC_METACLASS<span class="number">_</span><span class="variable">$_Foo</span></span><br><span class="line"></span><br><span class="line"><span class="number">000000000000013</span>8 (__DATA,__objc_data) <span class="keyword">external</span> _OBJC_CLASS<span class="number">_</span><span class="variable">$_Foo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和 Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> a.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                 (undefined) external _NSLog (from Foundation)</span><br><span class="line"></span><br><span class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</span><br><span class="line"></span><br><span class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</span><br><span class="line"></span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</span><br><span class="line"></span><br><span class="line">                 (undefined) external __objc_empty_cache (from libobjc)</span><br><span class="line"></span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</span><br><span class="line"></span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</span><br><span class="line"></span><br><span class="line">                 (undefined) external _objc_msgSend (from libobjc)</span><br><span class="line"></span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000000</span> (__TEXT,__text) <span class="selector-attr">[referenced dynamically]</span> external __mh_execute_header</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>e90 (__TEXT,__text) external _main</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100000</span>f10 (__TEXT,__text) non-external -<span class="selector-attr">[Foo say]</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000100001130</span> (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</span><br><span class="line"></span><br><span class="line"><span class="number">0000000100001158</span> (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun otool -L <span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a.out:</span><br><span class="line"></span><br><span class="line">	<span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/Versions/</span>C/Foundation (compatibility version <span class="number">300.0</span>.<span class="number">0</span>, current version <span class="number">1349.25</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="regexp">/usr/</span>lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span>.<span class="number">0</span>, current version <span class="number">1238.0</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CoreFoundation.framework<span class="regexp">/Versions/</span>A/CoreFoundation (compatibility version <span class="number">150.0</span>.<span class="number">0</span>, current version <span class="number">1348.28</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="regexp">/usr/</span>lib/libobjc.A.dylib (compatibility version <span class="number">1.0</span>.<span class="number">0</span>, current version <span class="number">228.0</span>.<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="built_in">export</span> <span class="attribute">DYLD_PRINT_LIBRARIES</span>=; ./a.out )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dyld: loaded: <span class="regexp">/Users/</span>didi<span class="regexp">/Downloads/</span>./a.out</span><br><span class="line"></span><br><span class="line">dyld: loaded: <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/Versions/</span>C/Foundation</span><br><span class="line"></span><br><span class="line">dyld: loaded: <span class="regexp">/usr/</span>lib/libSystem.B.dylib</span><br><span class="line"></span><br><span class="line">dyld: loaded: <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CoreFoundation.framework<span class="regexp">/Versions/</span>A/CoreFoundation</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line"></span><br><span class="line">&lt;/figure&gt;</span><br><span class="line"></span><br><span class="line">数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 <span class="regexp">/var/</span>db<span class="regexp">/dyld/</span>。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</span><br><span class="line"></span><br><span class="line">动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： [Dynamic Linking On OS X](https:<span class="comment">//www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)</span></span><br><span class="line"></span><br><span class="line">dyld 做了些什么事</span><br><span class="line"></span><br><span class="line">*   kernel 做启动程序初始准备，开始由dyld负责。</span><br><span class="line">*   基于非常简单的原始栈为 kernel 设置进程来启动自身。</span><br><span class="line">*   使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</span><br><span class="line">*   立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</span><br><span class="line">*   为可执行文件运行静态初始化。</span><br><span class="line">*   设置参数到可执行文件的 main 函数并调用它。</span><br><span class="line">*   在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 <span class="keyword">runtime</span> 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。<span class="keyword">runtime</span> 会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 <span class="keyword">Class</span>，按照继承层级依次调用 +load 方法。</span><br><span class="line">*   在 mian 函数返回后运行 <span class="keyword">static</span> terminator。</span><br><span class="line">*   在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</span><br><span class="line"></span><br><span class="line">查看运行时的调用 map_images 和 调用 +load 方法的相关 <span class="keyword">runtime</span> 处理可以通过 RetVal 的可debug 的 objc<span class="regexp">/runtime [RetVal/objc-runtime: objc runtime 706](https:/</span><span class="regexp">/github.com/</span>RetVal/objc-<span class="keyword">runtime</span>) 来进行断点查看调用的 <span class="keyword">runtime</span> 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>0  +[someclass load]</p>
<p>1  call_class_loads()</p>
<p>2  ::call_load_methods</p>
<p>3  ::load_images(const char *path __unused, const struct mach_header *mh)</p>
<p>4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</p>
<p>11 _dyld_start</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</span><br><span class="line"></span><br><span class="line">prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</span><br><span class="line"></span><br><span class="line">最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</span><br><span class="line"></span><br><span class="line">如果想了解 Cocoa 的 Fundation 库可以通过 [GNUStep](https:<span class="regexp">//gi</span>thub.com<span class="regexp">/AaronYi/g</span>nustep-base) 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</span><br><span class="line"></span><br><span class="line">dyld 是开源的： [GitHub - opensource-apple<span class="regexp">/dyld](https:/</span><span class="regexp">/github.com/</span>opensource-apple/dyld)</span><br><span class="line"></span><br><span class="line">还可以看看苹果的 WWDC 视频 [WWDC <span class="number">2016</span> Session <span class="number">406</span>](https:<span class="regexp">//</span>developer.apple.com<span class="regexp">/videos/</span>play<span class="regexp">/wwdc2016/</span><span class="number">406</span>/) 里讲解对启动进行优化。</span><br><span class="line"></span><br><span class="line">这篇文章也不错： [Dynamic Linking of Imported Functions <span class="keyword">in</span> Mach-O - CodeProject](https:<span class="regexp">//</span>www.codeproject.com<span class="regexp">/articles/</span><span class="number">187181</span>/dynamic-linking-of-imported-functions-<span class="keyword">in</span>-mach-o)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 附：安装编译 LLVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 多种获取方式</span></span><br><span class="line"></span><br><span class="line">*   官网：[http:<span class="regexp">//</span>releases.llvm.org<span class="regexp">/download.html](http:/</span><span class="regexp">/releases.llvm.org/</span>download.html)</span><br><span class="line">*   svn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>#先下载 LLVM

svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm

#在 LLVM 的 tools 目录下下载 Clang

cd llvm/tools

svn co http://llvm.org/svn/llvm-project/cfe/trunk clang

#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi

cd ../projects

svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt

svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx

svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi

#在 Clang 的 tools 下安装 extra 工具

cd ../tools/clang/tools

svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
</code></pre>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">*   </span>git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>git clone http://llvm.org/git/llvm.git

cd llvm/tools

git clone http://llvm.org/git/clang.git

cd ../projects

git clone http://llvm.org/git/compiler-rt.git

cd ../tools/clang/tools

git clone http://llvm.org/git/clang-tools-extra.git
</code></pre>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>brew install gcc</p>
<p>brew install cmake</p>
<p>mkdir build</p>
<p>cd build</p>
<p>cmake &#x2F;path&#x2F;to&#x2F;llvm&#x2F;source</p>
<p>cmake –build .</p>
<p>#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</p>
<p>mkdir xcodeBuild</p>
<p>cd xcodeBuild</p>
<p>cmake cmake -GXcode &#x2F;path&#x2F;to&#x2F;llvm&#x2F;source</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来可以看看 LLVM 的官方教程如何实现一个自己的编程语Kaleidoscope。 [LLVM Tutorial: Table of Contents — LLVM <span class="number">5</span> documentation](http:<span class="regexp">//</span>llvm.org<span class="regexp">/docs/</span>tutorial/index.html)</span><br><span class="line"></span><br><span class="line">这里有个使用swift的实现的系列教程</span><br><span class="line">[Building a Compiler <span class="keyword">in</span> Swift with LLVM](https:<span class="regexp">//</span>harlanhaskins.com<span class="regexp">/2017/</span><span class="number">01</span><span class="regexp">/08/</span>building-a-compiler-with-swift-<span class="keyword">in</span>-llvm-part-<span class="number">1</span>-introduction-and-the-lexer.html)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 附：Swift 编译</span></span><br><span class="line"></span><br><span class="line">官网： [GitHub - apple<span class="regexp">/swift: The Swift Programming Language](https:/</span><span class="regexp">/github.com/</span>apple/swift)</span><br><span class="line">swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： [Swift.org - Contributing](https:<span class="regexp">//</span>swift.org<span class="regexp">/contributing/</span><span class="comment">#contributing-code)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</p>
<p>brew install cmake ninja</p>
<p>mkdir swiftsource</p>
<p>cd swiftsource</p>
<p>#clone 下 swift 源码</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/apple/swift.git">https://github.com/apple/swift.git</a></p>
<p>#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;update-checkout –clone</p>
<p>#查看文件夹</p>
<p>du -h -d 1</p>
<p>#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;build-script -x -R</p>
<p>#更新</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;update-checkout</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;build-script -x -R</p>
<p>#切到指定tag和分支</p>
<p>#tag</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;update-checkout –tag swift-3.0-RELEASE</p>
<p>#特定分支</p>
<p>.&#x2F;swift&#x2F;utils&#x2F;update-checkout –scheme swift-3.0-branch</p>
<pre><code>
swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： [Swift.org - Source Code](https://swift.org/source-code/)

## 附：其它编译工具

### js写的C++解释器JSCPP

适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：[GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript](https://github.com/felixhao28/JSCPP)

## 附：资料网址

*   [http://llvm.org](http://llvm.org/)
*   [http://clang.llvm.org/](http://clang.llvm.org/)
*   [http://www.aosabook.org/en/llvm.html](http://www.aosabook.org/en/llvm.html)
*   [GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library](https://github.com/loarabia/Clang-tutorial)
*   [Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow](http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks)
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/04/Runtime/" rel="prev" title="Runtime">
      <i class="fa fa-chevron-left"></i> Runtime
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/03/05/iOS-block/" rel="next" title="iOS block">
      iOS block <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang-LLVM"><span class="nav-number">1.</span> <span class="nav-text">深入剖析 iOS 编译 Clang &#x2F; LLVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">编译流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang-%E7%BC%96%E8%AF%91-m-%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">Clang 编译 .m 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-Target"><span class="nav-number">1.4.</span> <span class="nav-text">构建 Target</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Target-%E5%9C%A8-Build-%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">Target 在 Build 过程的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Phases"><span class="nav-number">1.5.1.</span> <span class="nav-text">Build Phases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Rules"><span class="nav-number">1.5.2.</span> <span class="nav-text">Build Rules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Settings"><span class="nav-number">1.5.3.</span> <span class="nav-text">Build Settings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pbxproj%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.4.</span> <span class="nav-text">pbxproj工程文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang-Static-Analyzer%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.6.</span> <span class="nav-text">Clang Static Analyzer静态代码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CodeGen-%E7%94%9F%E6%88%90-IR-%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.</span> <span class="nav-text">CodeGen 生成 IR 代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang-Attributes"><span class="nav-number">1.8.</span> <span class="nav-text">Clang Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-format-NSString-F-A-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.8.1.</span> <span class="nav-text">attribute((format(NSString, F, A))) 格式化字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-deprecated-s-%E7%89%88%E6%9C%AC%E5%BC%83%E7%94%A8%E6%8F%90%E7%A4%BA"><span class="nav-number">1.8.2.</span> <span class="nav-text">attribute((deprecated(s))) 版本弃用提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-%E2%80%9D%E2%80%9D-VA-ARGS-%E6%8C%87%E6%98%8E%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E8%8C%83%E5%9B%B4"><span class="nav-number">1.8.3.</span> <span class="nav-text">attribute((availability(os,introduced&#x3D;m,deprecated&#x3D;n, obsoleted&#x3D;o,message&#x3D;”” VA_ARGS))) 指明使用版本范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-unavailable-%E2%80%A6-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%8F%AF%E7%94%A8%E6%8F%90%E7%A4%BA"><span class="nav-number">1.8.4.</span> <span class="nav-text">attribute((unavailable(…))) 方法不可用提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-unused"><span class="nav-number">1.8.5.</span> <span class="nav-text">attribute((unused))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-warn-unused-result"><span class="nav-number">1.8.6.</span> <span class="nav-text">attribute((warn_unused_result))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-availability-swift-unavailable-message-msg"><span class="nav-number">1.8.7.</span> <span class="nav-text">attribute((availability(swift, unavailable, message&#x3D;_msg)))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-cleanup-%E2%80%A6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%93%E6%9D%9F%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.8.</span> <span class="nav-text">attribute((cleanup(…))) 作用域结束时自动执行一个指定方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-overloadable-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">1.8.9.</span> <span class="nav-text">attribute((overloadable)) 方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-objc-designated-initializer-%E6%8C%87%E5%AE%9A%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.10.</span> <span class="nav-text">attribute((objc_designated_initializer)) 指定内部实现的初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-objc-subclassing-restricted-%E6%8C%87%E5%AE%9A%E4%B8%8D%E8%83%BD%E6%9C%89%E5%AD%90%E7%B1%BB"><span class="nav-number">1.8.11.</span> <span class="nav-text">attribute((objc_subclassing_restricted)) 指定不能有子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-objc-requires-super-%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%BF%85%E9%A1%BB%E8%B0%83%E7%94%A8-super"><span class="nav-number">1.8.12.</span> <span class="nav-text">attribute((objc_requires_super)) 子类继承必须调用 super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-const-%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E6%95%B0%E5%80%BC%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E8%BF%94%E5%9B%9E"><span class="nav-number">1.8.13.</span> <span class="nav-text">attribute((const)) 重复调用相同数值参数优化返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute-constructor-PRIORITY-%E5%92%8C-attribute-destructor-PRIORITY"><span class="nav-number">1.8.14.</span> <span class="nav-text">attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang-%E8%AD%A6%E5%91%8A%E5%A4%84%E7%90%86"><span class="nav-number">1.9.</span> <span class="nav-text">Clang 警告处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-libclang-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.10.</span> <span class="nav-text">使用 libclang 来进行语法分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LibTooling-%E5%AF%B9%E8%AF%AD%E6%B3%95%E6%A0%91%E5%AE%8C%E5%85%A8%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-number">1.11.</span> <span class="nav-text">LibTooling 对语法树完全的控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClangPlugin"><span class="nav-number">1.12.</span> <span class="nav-text">ClangPlugin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift-%E7%BC%96%E8%AF%91%E6%B5%81"><span class="nav-number">1.13.</span> <span class="nav-text">Swift 编译流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%86%85%E5%AE%B9-Link-Map-File"><span class="nav-number">1.14.</span> <span class="nav-text">编译后生成的二进制内容 Link Map File</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-files"><span class="nav-number">1.14.1.</span> <span class="nav-text">Object files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sections"><span class="nav-number">1.14.2.</span> <span class="nav-text">Sections</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbols"><span class="nav-number">1.14.3.</span> <span class="nav-text">Symbols</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E7%BC%96%E8%AF%91%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84-dSYM-%E6%96%87%E4%BB%B6"><span class="nav-number">1.15.</span> <span class="nav-text">每次编译后生成的 dSYM 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mach-O-%E6%96%87%E4%BB%B6"><span class="nav-number">1.16.</span> <span class="nav-text">Mach-O 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mach-O-%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="nav-number">1.16.1.</span> <span class="nav-text">Mach-O 文件的解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%90%91-Mach-O-%E6%96%87%E4%BB%B6"><span class="nav-number">1.16.2.</span> <span class="nav-text">逆向 Mach-O 文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dyld%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.17.</span> <span class="nav-text">dyld动态链接</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">suwang</p>
  <div class="site-description" itemprop="description">Tech Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suwang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
